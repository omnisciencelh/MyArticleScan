{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1654479920002281473",
        "title": "整合SpringSecurity自定义登录流程",
        "description": null,
        "content": "### 前言\n\n自定义登录流程是整合 SpringSecurity 开发必不可少的一步。[上篇文章](https://juejin.cn/post/7227020874888331324)我们介绍了整合数据库的登录，本篇文章在此基础上整理了 SpringSecurity + JWT + Redis 的登录流程。\n\n### 整体流程图\n\n登录及认证的整体流程如下图：\n\n![1683127723301-5c233af9-3c04-4e44-bada-a805cb4d73aa.png](https://pic.code-nav.cn/post_picture/1626574509983178753/uL6iuM5N-1683127723301-5c233af9-3c04-4e44-bada-a805cb4d73aa.png)\n\n### 依赖\n\n除了 SpringSecurity 的相关依赖外，还需要 Redis 和 hutool （强大且全面的工具包，本篇文章中 JWT 的相关类也来自该包） 的依赖。\n\n```xml\n<!-- springboot整合的redis依赖，里面集成了 spring-data-redis -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n<dependency>\n    <groupId>cn.hutool</groupId>\n    <artifactId>hutool-all</artifactId>\n    <version>5.8.13</version>\n</dependency>\n```\n\n### 配置\n\n在整个流程中，我们用到了 SpringSecurity + JWT + Redis ，需要配置的是SpringSecurity 和 Redis。\n\n##### SpringSecurity 配置\n\n```java\n@Configuration\npublic class SpringSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Resource\n    private JwtFilter jwtFilter;\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    /**\n     * 注入 AuthenticationManager 对象，用于调用认证方法\n     *\n     * @return\n     * @throws Exception\n     */\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n    /**\n     * 放行登录接口\n     */\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                // 关闭csrf\n                .csrf().disable()\n                // 不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                // 把jwt过滤器放到UsernamePasswordAuthenticationFilter前,便于先判断用户是否登录,再决定是否登录\n                .authorizeRequests()\n                // 对于登录接口允许匿名访问\n                .antMatchers(\"/user/login\").anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n        http.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);\n\n    }\n\n}\n\n```\n\n在配置类中，我们注入了 AuthenticationManager 对象。这个对象在上篇文章我们提到过，用于调用认证方法。但是在父类 WebSecurityConfigurerAdapter 中并没有将它注入到容器中，而我们又需要在自己的登录接口中调用它，因此需要重写 authenticationManagerBean 方法并将返回的对象注入到容器中。\nconfigure(HttpSecurity http) 方法用于配置路由，只开放登录接口，其他接口都需要认证。\n\n##### Redis配置\n\n```java\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        // 设置序列化\n        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<Object>(\n                Object.class);\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        om.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        // 配置redisTemplate\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<String, Object>();\n        redisTemplate.setConnectionFactory(lettuceConnectionFactory);\n        RedisSerializer<?> stringSerializer = new StringRedisSerializer();\n        redisTemplate.setKeySerializer(stringSerializer);// key序列化\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);// value序列化\n        redisTemplate.setHashKeySerializer(stringSerializer);// Hash key序列化\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);// Hash value序列化\n        redisTemplate.afterPropertiesSet();\n        return redisTemplate;\n    }\n}\n\n\n```\n\n在 Redis 配置中大部分是常规的序列化配置，特殊的是 ObjectMapper ，这个配置是为因为存储在 Redis 的实体类中除了成员变量的 get 方法外，其他方法不能有返回值，否则会导致反序列化异常，而 ObjectMapper 就是为了解决这个问题。\n反序列化异常的问题可以通过下面的代码验证\n\n```java\n@Test\npublic void test(){\n    RedisTestEntity entity = new RedisTestEntity();\n    entity.setName(\"111\");\n    redisTemplate.opsForValue().set(\"name\", entity);\n}\n\n@Test\npublic void get(){\n    Object name = redisTemplate.opsForValue().get(\"name\");\n    System.out.println(name);\n}\n\n@Data\npublic class RedisTestEntity {\n    private String name;\n\n    public Integer requireAge(){\n        return 18;\n    }\n}\n```\n\n### 定义登录接口\n\n##### 参数的接收\n\n```java\n@Data\npublic class UserLogin {\n    private String username;\n    private String password;\n}\n```\n\n##### controller部分\n\n```java\n@PostMapping(\"/login\")\npublic R<String> login(@RequestBody UserLogin userLogin){\n    String jwt = securityService.login(userLogin);\n    return R.success().data(jwt);\n}\n```\n\ncontroller 只是负责匹配路由和返回数据，业务通过 service 的相关方法完成，因此 controller 中没有太多代码\n\n##### service部分\n\n```java\n@Resource\nprivate AuthenticationManager manager;\n@Resource\nprivate RedisTemplate redisTemplate;\n@Override\npublic String login(UserLogin userLogin) {\n    Authentication userAuthentication = new UsernamePasswordAuthenticationToken(userLogin.getUsername(), userLogin.getPassword());\n    Authentication authenticate = manager.authenticate(userAuthentication);\n    // 如果认证成功则进入生成token的逻辑\n    if (authenticate.isAuthenticated()) {\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\n        SysUser user = loginUser.getUser();\n        // 将登录成功的对象存入redis\n        redisTemplate.opsForValue().set(KeyUtil.getLoginUserKey(user.getUserId()), loginUser);\n        // 生成token\n        String token = JWT\n                .create()\n                .setPayload(userLoginId, user.getUserId())\n                // (签发时间)---------(生效时间)---------(当前时间)---------(失效时间)\n                .setIssuedAt(new Date())\n                // 过期时间七天\n                .setExpiresAt(new Date(System.currentTimeMillis() + DateUnit.WEEK.getMillis()))\n                // // 设置HS256为加密算法，以用户的密码为盐（密钥）\n                .setSigner(\"HMD5\", salt.getBytes(StandardCharsets.UTF_8))\n                .sign();\n\n        return token;\n    }\n    throw new RuntimeException(\"用户名或密码错误\");\n}\n```\n\nservice 完成了登录的主要流程，包括：\n\n1. 调用 AuthenticationManager 实例的 authenticate 方法对用户的账号密码进行验证，该方法会调用到我们上篇文章自定义的方法，通过查询数据库的数据完成校验\n2. 如果校验成功，则将用户信息存入 Redis 并生成相应 token ，同时将用户 id 存入 token 的荷载中，失败则抛出异常\n\n### 登录过滤器\n\n完成登录后，在以后的每次请求都需要在请求头中带上 token 以便于认证，认证操作通过过滤器完成（关于 jwt 的具体知识本篇文章不做探讨，不熟悉请自行查阅相关资料）。\n\n```java\n@Component\npublic class JwtFilter extends OncePerRequestFilter {\n\n    @Resource\n    private RedisTemplate redisTemplate;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        String token = request.getHeader(\"token\");\n        // 没有token，去走登录流程\n        if (StrUtil.isBlank(token)) {\n            filterChain.doFilter(request, response);\n            return;\n        }\n        // token不能为空\n        JWT jwt = JWTUtil.parseToken(token);\n        // 验证token是否合法\n        HMacJWTSigner singer = new HMacJWTSigner(AlgorithmUtil.getAlgorithm(\"HMD5\"), salt.getBytes(StandardCharsets.UTF_8));\n        boolean common = jwt.verify(singer);\n        // 验证时间，失败会抛出异常\n        try {\n            JWTValidator.of(jwt).validateDate(DateUtil.date());\n        } catch (ValidateException exception) {\n            throw new TokenInvalidException(\"token异常\");\n        }\n        if (common){\n            NumberWithFormat userIdObj = (NumberWithFormat)jwt.getPayload(userLoginId);\n            Integer userId = userIdObj.intValue();\n            LoginUser loginUser = (LoginUser) redisTemplate.opsForValue().get(KeyUtil.getLoginUserKey(userId));\n            // 如果用户不存在，说明token异常\n            if (loginUser == null) {\n                throw new TokenInvalidException(\"token异常\");\n            }\n\n            // 将用户信息存入 SecurityContextHolder ，以便本次在请求中使用\n            UsernamePasswordAuthenticationToken authenticationLoginUser = new UsernamePasswordAuthenticationToken(loginUser, null, null);\n            SecurityContextHolder.getContext().setAuthentication(authenticationLoginUser);\n\n            filterChain.doFilter(request, response);\n        }\n\n    }\n}\n```\n\n我们自定义的过滤器类继承了 OncePerRequestFilter 类并重写了 doFilterInternal 方法，然后在 SpringSecurity 的配置类中将其添加到 UsernamePasswordAuthenticationFilter 前面（校验账号密码之前），对应配置类中的如下代码\n\n```java\nhttp.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);\n```\n\n在过滤器中，我们首先校验了 token 是否存在。如果不存在则直接放行，然后在后续校验权限时会被自动拦截下来。存在则验证 token 的合法性，通过后从 token 拿到用户 id ，从 Redis 中获取到用户信息，如果不存在说明用户的登录状态异常（可能是退出了登录状态，后文会说）。从 Redis 中取到用户信息后，就可以将用户信息存到 SecurityContextHolder 中，方便后续进行认证、授权以及使用。最后放行，执行后续操作。\n\n### 退出登录\n\n在做完前面的操作后，退出登录的操作就很简单了。\n\n```java\n@PostMapping(\"/logout\")\npublic R<String> logout(){\n    Boolean delete = securityService.logout();\n    return R.success().data(delete);\n}\n```\n\n```java\n@Override\npublic Boolean logout() {\n    LoginUser loginUser = (LoginUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n    Integer userId = loginUser.getUser().getUserId();\n    Boolean delete = redisTemplate.delete(KeyUtil.getLoginUserKey(userId));\n    return delete;\n}\n```\n\ncontroller 和 service 的代码分别如图。\n在 service 中我们删除了 Redis 中的用户信息，这也就解释了为什么过滤器中会存在 token 合法但是用户信息不存在的情况（退出登录），当然也可能有其它的特殊情况。\n\n### 结语\n\n本篇文章就到这了，下一篇应该是关于授权的内容，我们下次再见。",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 13,
        "thumbNum": 1,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1626574509983178753",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-05-05T13:35:26.000+00:00",
        "updateTime": "2023-05-06T01:47:02.000+00:00",
        "user": {
          "id": "1626574509983178753",
          "planetCode": "452",
          "userName": "松柏",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1626574509983178753/ExDo1T3f-wallhaven-72rxqo.jpg",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-02-20T11:07:05.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-17T13:29:18.000+00:00",
          "updateTime": "2023-05-05T07:20:20.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "Redis"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1654479553654992898",
        "title": "初识 Spring Security",
        "description": null,
        "content": "### 前言\n\nSpring Security 是什么呢，在官网里时这样描述的\n\n> Spring Security是一个框架，提供 认证（authentication）、授权（authorization） 和 保护，以抵御常见的攻击。它对保护命令式和响应式应用程序有一流的支持，是保护基于Spring的应用程序的事实标准。\n\n简而言之就是一个安全框架，能够很好的保护我们的 Spring 应用\n\n### Spring Security执行流程（简化）\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1626574509983178753/NDLHc9LJ-image.png)\n（图来自B站：三更草堂）\n从图中可以看到，用户输入的用户名密码会被一路传到 DaoAuthenticationProvider（后文简称 DAP ）， 然后由 InMemoryUserDetailsManager （实现了 UserDetailsService 接口）根据用户名从内存中查找到对应的用户信息并返回给 DAP 。 DAP 将查到的信息与用户输入的信息进行比对，如果正确则返回并存储认证对象（没有json返回值）。\n\n### 整合数据库\n\n上面提到，Spring Security 默认是在内存中查找用户信息，这是不符合我们实际开发的场景的。我们需要从数据库中查到真实的用户信息。\n这时候就需要用到 UserDetailsService 接口，因为最后查找用户的操作是由该接口定义的，我们只需要实现该接口并实现 loadUserByUsername 方法，即可实现从数据库中查找用户信息。\n\n```java\n    @Resource\n    private SysUserService sysUserService;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        SysUser user = sysUserService.getUserByUserName(username);\n        if (user == null) {\n            throw new RuntimeException(\"账号或密码错误\");\n        }\n        LoginUser loginUser = new LoginUser(user);\n        return loginUser;\n    }\n```\n\nloadUserByUsername 方法要求返回的 UserDeatils 对象是 Spring Security 的内置用户对象，我们可以通过组合的方式将查出的用户封装为 UserDeatils 对象。\n\n```java\npackage com.cowz.databasedemo.entity.security;\n\nimport com.cowz.databasedemo.entity.SysUser;\nimport lombok.AllArgsConstructor;\nimport lombok.NoArgsConstructor;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\n\n@NoArgsConstructor\n@AllArgsConstructor\npublic class LoginUser implements UserDetails {\n\n    private SysUser user;\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return null;\n    }\n\n    @Override\n    public String getPassword() {\n        return user.getPassword();\n    }\n\n    @Override\n    public String getUsername() {\n        return user.getUsername();\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n\n```\n\n其中 SysUser 就是我们系统中的用户对象。\n\n### 密码加密器\n\n做完以上操作在进行测试时，会报一个异常\n\n```java\njava.lang.IllegalArgumentException:There is no PasswordEncoder mapped for the id \"null\"\n```\n\n这是由于没有配置密码加密器所引起的，密码加密器确保我们的密码在数据库中是以密文而不是明文存储的。为此我们需要进行以下的配置\n\n```java\n@Configuration\npublic class SpringSecurityConfig {\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 5,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1626574509983178753",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-05-05T13:33:59.000+00:00",
        "updateTime": "2023-05-06T01:39:59.000+00:00",
        "user": {
          "id": "1626574509983178753",
          "planetCode": "452",
          "userName": "松柏",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1626574509983178753/ExDo1T3f-wallhaven-72rxqo.jpg",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-02-20T11:07:05.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-17T13:29:18.000+00:00",
          "updateTime": "2023-05-05T07:20:20.000+00:00"
        },
        "tags": [
          "文章",
          "Spring",
          "后端",
          "安全"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1654381139428683778",
        "title": "Bito插件试用",
        "description": "OpenAI 官方出品插件 整体体验不错👍",
        "content": "Bito插件试用\nOpenAI 官方出品插件\n整体体验不错👍\nhttps://www.yuque.com/shayushitiande/atxmt2/rxspvzzgemigepne?singleDoc# 《Bito》",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 15,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1608753663864471554",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-05-05T07:02:55.000+00:00",
        "updateTime": "2023-05-06T01:50:22.000+00:00",
        "user": {
          "id": "1608753663864471554",
          "planetCode": "931",
          "userName": "沙鱼",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/Ant4yt5goWCB6iaTUWl3tq8m9ibIy69vKTH7gF41YcDMDvT4nP0MBO4z8pbqKrhUOn1ZZemJQbaXicHBOpYJtftDg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-02-18T14:53:56.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-30T09:15:37.000+00:00",
          "updateTime": "2023-05-05T05:35:49.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1654376152560611329",
        "title": "RPC原理与实现",
        "description": null,
        "content": "\n## 什么是RPC？\n\nRPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。\n\n那么我们至少从这样的描述中挖掘出几个要点：\n\n- RPC是**协议**：既然是协议就只是一套规范，那么就需要有人遵循这套规范来进行实现。目前典型的RPC实现包括：Dubbo、Thrift、GRPC、Hetty等。\n- **网络协议和网络IO模型对其透明**：既然RPC的客户端认为自己是在调用本地对象。那么传输层使用的是TCP/UDP还是HTTP协议，又或者是一些其他的网络协议它就不需要关心了。\n- **信息格式对其透明**：我们知道在本地应用程序中，对于某个对象的调用需要传递一些参数，并且会返回一个调用结果。至于被调用的对象内部是如何使用这些参数，并计算出处理结果的，调用方是不需要关心的。那么对于远程调用来说，这些参数会以某种信息格式传递给网络上的另外一台计算机，这个信息格式是怎样构成的，调用方是不需要关心的。\n- **应该有跨语言能力**：为什么这样说呢？因为调用方实际上也不清楚远程服务器的应用程序是使用什么语言运行的。那么对于调用方来说，无论服务器方使用的是什么语言，本次调用都应该成功，并且返回值也应该按照调用方程序语言所能理解的形式进行描述。\n\n\n![image-20230413134629079.png](https://pic.code-nav.cn/post_picture/1626450481553383425/xfh5e0hA-image-20230413134629079.png)\n\n那要怎样实现透明化远程调用呢？要让开发者无感知的调用远程方法呢？答案就是动态代理！！！\n\n动态代理会通过反射获取到远程服务的接口，当执行本地方法时就会调用`invoke`方法，进行通信相关逻辑，最后成功调用。所以还记得为什么要在进行远程调用的时候消费者和服务者都要定义接口信息，所以**公共模块就可以把Service的接口提取出来**。\n\n### 什么是动态代理\n\n虽然上面说到需要用到动态代理，但是这个玩意儿到底是个啥，所以这里也可以简单聊一聊。\n\n代理其实是一种结构性`设计模式`。可以控制对类对象的访问，在访问类对象时增加额外功能。类似与下图所示，代理会获取到当前接口的实现类，并在其基础上进行增强。\n\n![image-20230413125527475.png](https://pic.code-nav.cn/post_picture/1626450481553383425/X8ceMVbZ-image-20230413125527475.png)\n\n而代理又分为静态代理和动态代理，他们的区分方式是`代理关系是否在编译期确定`。\n\n#### 静态代理\n\n就比如现在想去租房，然后现在只有中介手里才有房源，所以你就可以跟中介进行沟通，而不用去直接和房东沟通。因为在编译期就知道了代理关系，所以是静态代理。通俗的来讲就是你事先知道这个中介是买房子的。\n\n但是静态代理存在一定的缺陷，`重复性`：随着业务的增加需要编写很多模板代码，也就解释了为什么不适用静态代理实现RPC框架。`脆弱性`：一旦基础接口改动，代理类也需要同步修改。\n\n#### 动态代理（通用+兼容多个业务）\n\n同样是中介，只不过这次的中介是拼命三郎，一天打n份工，不仅卖房，还卖车，还卖酒，各种。。。也就是说在联系之前，我们是不知道它卖的是什么？但是见面之后你告诉他需求，他就能帮你找到！是不能提前知道代理关系，所以是动态代理。\n\n动态代理一般有JDK、CGLIB、JavaScript几种实现方式。这里只讨论JDK。它可以利用反射机制在运行时生成的类的字节码，主要是利用Invoke函数去直接访问基础对象，另外也可以通过使用泛型来实现兼容多个业务接口。\n\n对比来看！静态代理就是提前确定一个类，需要把所有的类都提前确定，而动态代理则是可以将类细节隐藏，同时负责多个接口。另外静态代理的类字节码是在编译期就确定的，而动态代理则是在运行时生成的。他们的相同点就是可以不修改原来的对象，只是自己新创建一个对象进行扩展。但重点是控制对于原有对象的访问。\n\n> 这里额外的进行一个扩展，刚刚提到的代理模式，是不是与装饰器模式特别像，至少在功能扩展上是的吧\n> 装饰器模式强调的是增强自身，在被装饰之后你能够在被增强的类上使用增强后的功能。增强后你还是你，只不过能力更强了而已；代理模式强调要让别人帮你去做一些本身与你业务没有太多关系的职责（记录日志、设置缓存）。\n>\n> 1. 代理模式是为了实现对象的控制，因为被代理的对象往往难以直接获得或者是其内部不想暴露出来。\n> 2. 装饰模式是以对客户端透明的方式扩展对象的功能，是继承方案的一个替代方案；代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用；\n> 3. 装饰模式是为装饰的对象增强功能；而代理模式对代理的对象施加控制，但不对对象本身的功能进行增强；\n\n解释清楚了什么是动态代理，那么中间有提到反射，这又又又是一个技术深入的点。\n\n### 什么是反射\n\n刚才有提到利用反射获取的类的字节码。是的，反射的作用就是在运行时动态的获取类。\n\n在开始之前，先来梳理一下Java的类型模型，首先Java是一个强类型语言，就是变量有固定的类型。另外Java是一个静态语言，即类型检查更偏向于编译时执行，但是也不全部都是，Java有时也会在运行时进行类型检查，比如Object对象的类型检查。\n\n现在想象一下Python在进行变量的创建与接收的时候不用判断类型，同样的，Java通过`反射`也拥有了这样的特性。我们可以直接获取类的对象，进而获取其全部属性。\n\n实质上，反射的实现就是将生成的Class对象直接拿到内存来用，通过Native方法来实现这个过程，而当反射执行次数较多时，通过ASM字节码生成新的类，并将以后的反射委派给新类。\n\n## RPC的实现\n\n讲完了RPC的原理，接下来就是它的实现方式。\n\n常见的几种实现方式包括`grpc` `Thrift` `Dubbo`,这里主要通过DUBBO来实现RPC。官网上是这样说的，提供**高性能通信**和**服务治理**能力的微服务开发框架。\n\n### 高性能通信\n\n#### 高性能数据传输\n\n内置支持Dubbo2、Tripe两个高性能通信协议\n\n- Dubbo2 是基于 TCP 传输协议之上构建的二进制私有 RPC 通信协议，是一款非常简单、紧凑、高效的通信协议\n- Triple 是基于 HTTP/2 的新一代 RPC 通信协议，在网关穿透性、通用性以及 Streaming 通信上具备优势，Triple 完全兼容 gRPC 协议\n\n#### 流式通信\n\n业务的迅速增长会使得集群规模增加，从而带来服务治理问题：\n\n- 注册中心的存储瓶颈\n- 节点动态变化地址推送与解析效率下降\n- 复杂网络链路管理\n\n### 服务治理\n\n#### 流量管控\n\nDubbo 丰富的流量管控规则可以控制服务间的流量走向和 API 调用，基于这些规则可以实现在运行期动态的调整服务行为如超时时间、重试次数、限流参数等，通过控制流量分布可以实现 A/B 测试、金丝雀发布、多版本按比例流量分配、条件匹配路由、黑白名单等，提高系统稳定性。\n\n#### 微服务生态\n\n具有较好的扩展机制，对于大多数服务治理需求都可满足，也可以通过扩展机制轻松适配。\n\nEmmm....感觉框架和应用大致了解一下设计思想，清除一下相关技术替代品，能够在合适的场景下用就好\n\n## Reference\n\n[JDK动态代理的原理其实很简答](https://juejin.cn/post/6974018412158664734)\n\n[反射机制](https://juejin.cn/post/6889833658669072397)\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1626450481553383425/xhQcqRz7-1f9187c7a5e94f8fab57c54a52b9fff0.jpg",
        "language": null,
        "viewNum": 12,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1626450481553383425",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-05-05T06:43:06.000+00:00",
        "updateTime": "2023-05-06T01:12:24.000+00:00",
        "user": {
          "id": "1626450481553383425",
          "planetCode": "16378",
          "userName": "beeran",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1626450481553383425/H1EQ2NWG-beeran.jpg",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": "广州大学",
          "major": "网络空间安全",
          "education": "一本",
          "graduationYear": 2024,
          "jobStatus": "求职中",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "实习",
          "github": "https://github.com/tc6-01",
          "blog": "beeran.space",
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-02-19T23:03:39.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-17T05:16:27.000+00:00",
          "updateTime": "2023-03-21T04:17:43.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1654008802426531841",
        "title": "送了老弟一台 Linux 服务器，它又懵了！",
        "description": null,
        "content": "大家好，我是鱼皮。\n\n前两天我学编程的老弟小阿巴过生日，我问他想要什么礼物。\n\n本来以为他会要什么游戏机、Q 币卡、鼠标键盘啥的，结果小阿巴说：我想要一台服务器。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230417170739167.png)\n\n鱼皮听了，不禁称赞道：真是个学编程的好苗子啊，行，我就送你一台最低配的 Linux 服务器吧！1 核 1 G 的那种。\n\n小阿巴（感动）：我焯，谢谢哥，但为什么送我最低配的呢？\n\n鱼皮：对初学 Linux 的同学来说，一般不会部署特别大的项目，1 核 1 G 的服务器，无论是用来学习 Linux 命令，还是用来部署个人博客和小项目都已经足够了。后续如果需要用到更高的配置，再升级即可。\n\n小阿巴：原来如此，之前就听说有同学买了 Linux 服务器后，由于不会用，就积灰了。那我先拿这个机子学习！\n\n鱼皮：不错，你先自己摸索一下，就当平时的办公电脑一样用试试~\n\n\n\n1 小时后。。。\n\n鱼皮：怎么样，知道怎么使用 Linux 了么？\n\n小阿巴：阿巴阿巴。。。这服务器为啥没界面啊！我不懂玩。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230417171533623.png)\n\n鱼皮：我送你的服务器安装的是 Linux 的一个发行版 —— CentOS 系统，默认是没有 Windows 和 Mac 那样的图形界面的，而是需要使用 `命令行` 来操作哦。\n\n小阿巴：！为啥 Linux 要这么设计啊，它为啥不像 Windows 一样用图形界面呢？\n\n鱼皮：这里其实是非常有考究的。正因为如此设计，不运行图形界面，能够大幅节省系统的资源，从而提高系统的 **资源利用率** ，运行更多的项目（程序）。而且 Linux 支持多用户远程登录，不运行图形界面也可以一定程度上保证系统的稳定性。\n\n高性能、低成本、更稳定，也是 Linux 服务器被广泛应用于生产环境部署项目的重要原因。\n\n小阿巴：原来如此，我可算知道为啥说程序员都要学习 Linux 了。那我现在应该怎么入门 Linux 呢？面对小黑框框我一脸懵逼啊。。。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230417173242558.png)\n\n鱼皮：可以看下我之前写的 [Linux 学习路线](https://mp.weixin.qq.com/s?__biz=MzI1NDczNTAwMA==&mid=2247501290&idx=1&sn=05437a67ba6888eeab253e554b693ceb&chksm=e9c2221ddeb5ab0b8b3d01651fcf41cccf1f0e5e1304e8441bfad789eb92d57d06a72f624c1e&token=706151027&lang=zh_CN#rd) ，入门 Linux 首先要做的就是 **了解 Linux 的常用命令** ，能做到像用界面操作 Windows 一样灵活操作 Linux，那你就成功了！\n\n小阿巴：的确，好像我之前经常在别人的简历上看到 “了解 Linux 命令” ，那我应该了解哪些 Linux 命令呢？\n\n鱼皮：Linux 的常用命令可以分为几大类，简单给你介绍一下吧。\n\n\n\n### Linux 常用命令\n\n#### 文件操作命令\n\n> 学习优先级最高，Linux 一切皆文件\n\n- pwd：显示当前所在目录\n- ls：查看目录下的文件\n- mkdir：创建目录\n- cd：切换当前目录\n- mv：移动文件或目录\n- cp：复制文件或目录\n- rm：删除文件或目录\n- zip：压缩文件\n- unzip：解压文件\n\n\n\n#### 系统信息命令\n\n> 后端开发重点，可使用这些命令进行异常分析\n\n- top：查看进程及资源占用情况\n- ps：查看进程信息\n- free：查看内存占用情况\n- df：查看磁盘占用情况\n- ifconfig：查看网络接口信息\n- netstat：查看网络状态信息\n\n\n\n#### 文件查看命令\n\n> 后端开发重点，可使用这些命令快速定位项目日志中的异常信息\n\n- cat：查看文件内容\n- head：查看文件开头内容\n- tail：查看文件末尾内容\n- grep、sed、awk 三剑客：灵活查找和处理文件内容\n\n\n\n#### 用户权限命令\n\n> 一般是给 Linux 运维（管理员）使用\n\n- useradd：添加用户\n- userdel：删除用户\n- chmod：修改文件或目录权限\n- chown：修改文件或目录所有者\n\n\n\n鱼皮：当然，以上只是 **部分** 常用命令，Linux 还有很多实用的第三方库和命令，感兴趣可以自己探索下~\n\n小阿巴：谢谢鱼皮，我这就去学习命令，背单词我最擅长！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230417173707444.png)\n\n鱼皮：记住，学 Linux 命令不要去死记硬背！把每个命令都敲几遍，有个大概的印象，后面部署项目的时候多操作下自然就熟悉了。像我们在工作中，也不会刻意去背这些命令，如果忘记了某个命令的用法，可以直接用 `命令 --help` 快速查看帮助文档，或者通过 Linux 命令集网站查询即可，比如：https://www.linuxcool.com/。\n\n小阿巴：谢谢，我刚刚查到一个命令： `rm -rf /*` ，这就去试试！\n\n鱼皮：住手啊！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230417175215280.png)\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 70,
        "thumbNum": 5,
        "favourNum": 1,
        "commentNum": 1,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-05-04T06:23:23.000+00:00",
        "updateTime": "2023-05-06T01:23:29.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 1310,
          "coin": 170,
          "followeeNum": 599,
          "followNum": 5,
          "followStatus": null,
          "vipExpireTime": "2025-12-17T05:00:02.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-05-05T14:37:02.000+00:00"
        },
        "tags": [
          "文章",
          "Linux",
          "服务器"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1653029878414487553",
        "title": "解决 bug 的经验",
        "description": "程序员，如何写出更少 bug 的代码，如何解决遇到的 bug",
        "content": "## 如何快乐高效的解决 bug\n\n​\t五一，当然要劳动啦！大家五一节日快乐！\n\n​\t刚学习编程那会，我也和很多小伙伴一样，害怕红色的bug，现在，我会和乐意去解决遇到的每一个 bug、因为我知道解决了它，我会变的更厉害\n\n​\t程序员，也就是使用一门语言编写可靠的代码去解决实际的需求，但是即使是世界上最优秀的程序员，也不能保证他写的代码没有任何问题。那么，一个优秀的程序员，应该是同时拥有**编写出良好的代码的能力**和**解决bug的能力**，而且解决 bug 的能力更加重要，因为写代码是在自己熟悉的领域输出，解决 bug 是学习新的知识，跳出舒适圈\n\n​\t首先作为一个程序员，只要是写代码，肯定是会产生 bug，除非这个人不写代码，所以每个程序员需心平气和的接受。要是有个人说自己写代码没有出现过bug，那这个人肯定是骗你的或者这个人很自大。但并不代表你产生的 bug 越多你就越牛，我们在编程的时候，肯定是要采取各种手段避免 bug 的发生。例如：前端的 Typescript，它就是为了减少 bug 。\n\n​\t接下来，我来讲一下，我个人在解决无数 bug 后的一点经验，\n\n#### 心态要好\n\n> 放在最前面，是我认为这是最重要的事情\n\n**在修复bug过程中，最重要的一个心态就是切莫急躁，急躁是修复不了bug的。** 面对bug要有以下的心态转变：\n\n1. **保持耐心和冷静**：慌张和急躁可能导致错误的决策和低效的解决方案。从容地分析问题，遵循解决bug的方法一步一步地解决，\n2. **积极主动地寻求帮助**：如果遇到难以解决的问题，不要犹豫向团队成员、社区或互联网寻求帮助。同事和社区成员可能会提供有价值的建议和指导。同时，这种互助和分享的过程有助于团队成长和知识传递。\n3. **看待Bug作为学习和成长的机会**：将Bug视为学习新技能、深入了解系统和提高解决问题能力的机会。从中吸取教训，提高自己的技能和经验。如果你解决 bug 后，回想，你会发现你成长了，学到了新的知识，\n4. 保持乐观，自信，相信自己能解决这个问题\n5. 面对复杂的bug，适时地的休息和调整\n6. 最后一定要 🎉 ，自己成功解决了 bug\n\n#### 解决bug的思路，方法\n\n> 往往一个 bug ，是因为我们的粗心，或者对业务的不理解导致的\n\n1. **复现 bug**：确保Bug不是由于理解错误或设计改动导致的。\n2. **收集 bug 相关信息**；这包括：\n   1. Bug出现的频率和条件\n   2. Bug的影响范围\n   3. 报告Bug的用户或同事提供的信息\n   4. 测试环境、开发环境或生产环境中的错误日志\n   5. 浏览器控制台中的错误信息（针对前端Bug）\n3. **缩小问题范围**：通过分析收集到的信息，缩小问题所在的范围。以下是一些建议：\n   1. 将复杂问题拆分为更小、更简单的部分\n   2. 使用二分法逐步缩小问题范围\n   3. 确定问题发生在哪个模块或组件中\n   4. 确定问题是由前端还是后端引起的\n   5. 确定问题与特定浏览器、操作系统或设备有关还是普遍存在\n4. **问题定位**：找到问题的根源。在这个阶段，需要：\n   1. 阅读相关代码，了解逻辑\n   2. 使用调试工具（如浏览器的开发者工具或IDE中的**断点**调试功能）进行逐步调试，最常见的就是我们的 **Debug**\n   3. 观察变量值和执行流程，了解它们与预期的差异\n   4. 对后端代码，可以使用日志记录或断点调试来监控关键变量和执行路径\n   5. 对前端代码，可以使用浏览器的开发者工具进行实时调试，查看HTML、CSS和JavaScript中的问题\n5. **设计解决方案**：（对于复杂问题）在设计解决方案时，要考虑以下因素：\n   1. 解决方案是否有效地解决了问题\n   2. 解决方案是否会引入新的Bug或问题\n   3. 解决方案是否符合代码规范和设计原则\n   4. 解决方案的性能影响\n   5. 解决方案的可维护性和可扩展性\n6. **执行方案**：\n   1. 编写可读、简洁和高效的代码\n   2. 遵循团队约定和编码风格\n   3. 对修改过的代码片段进行注释，解释更改的原因和实现方法\n7. **测试**：\n   1. 重新尝试重现Bug，确保问题已解决\n   2. 对修改过的功能或模块进行详尽测试\n   3. 对相关功能进行回归测试，确保更改没有产生副作用\n   4. 在不同浏览器、操作系统和设备上进行兼容性测试（针对前端开发）\n8. **代码 review，确保没有引入新的问题**：\n   1. 向同事解释Bug的根本原因以及解决方案的设计\n   2. 讨论解决方案的优缺点，以及可能的改进方法\n   3. 根据团队成员的反馈进行调整和优化\n9. **整理文档**：解决Bug的过程中可能会发现一些值得记录和分享的经验。请务必撰写文档，将这些经验分享给团队成员，以便今后遇到类似问题时能够迅速解决。同时，从中汲取教训，改进开发和测试流程，以减少类似Bug的出现。\n10. **持续改进，以小见大**，在解决Bug后，要反思整个过程，思考如何改进开发流程、测试策略和团队协作。这有助于降低未来Bug的产生，提高软件质量，为用户提供更好的体验。\n\n#### 如何减少 bug\n\n> 无论怎么说，bug 都是不好的，也都是由于我们导致产生的，那么减少 bug 的产生，是不是也很重要呢？我总结了一些减少写出 bug 代码的方法，其实一句话说就是写代码前要先做准备\n\n1. **计划和设计**：在编写代码之前，充分了解需求、功能和目标。合理地规划和设计程序结构，以便创建可维护、可扩展和稳定的代码。很多 bug 其实都是对业务的不熟悉导致的，\n2. **遵循编码规范和风格指南**：遵循团队和行业的编码规范和风格指南，以确保代码具有一致性和可读性。这有助于减少因不一致和混乱而导致的Bug。例如：前端的 Eslint + prettier，极大的提高代码的可读性\n3. **写简洁，模块化的代码**：编写简洁、易于理解的代码。将代码拆分为独立、可重用的模块或组件，以降低复杂性和出错的可能性。\n4. **使用版本控制**，使用版本控制系统（如Git），以便跟踪代码更改、回滚错误的提交以及更容易地协作。通过代码审查，确保Bug在合并到主分支之前被发现和修复。\n\n5. **注释和文档**：为关键部分和复杂逻辑编写注释，以便其他开发者（以及您自己）能够更容易地理解和维护代码。同时，撰写详细的文档，说明程序的功能、架构和使用方法。\n6. **单元测试和自动化测试**：编写单元测试以检查代码的正确性和稳定性。通过自动化测试框架，确保在每次更改后运行测试，以便快速发现和修复Bug。同时，考虑编写集成测试、端到端测试和回归测试以确保整个系统的稳定性。\n7. **代码审查**：定期的代码审查，以便发现潜在问题并在早期阶段进行修复。这有助于提高代码质量，分享知识并保持团队间的一致性。\n8. **重构**：定期对代码进行重构，以改进其结构、提高可读性和性能。重构有助于消除潜在的Bug并减少新Bug的产生。\n9. **学习和使用设计模式**：了解和应用设计模式。设计模式是在特定情况下解决特定问题的经过验证的解决方案。它们可以帮助您编写更可维护、可扩展和稳定的代码，从而减少Bug的发生\n10. **持续学习提高自己的技术能力，学习新技术，最佳实践和编程原理，阅读优秀，经典书籍，学习计算机基础知识**\n\n最后，希望大家都能写出优秀的代码，做出自己满意的产品，通过 code ，让世界变得更好！",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/JwBjZd4c-mt-1543479563.jpeg",
        "language": null,
        "viewNum": 51,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-05-01T13:33:29.000+00:00",
        "updateTime": "2023-05-05T15:57:57.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 5,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-06T23:06:53.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-04-29T12:23:26.000+00:00"
        },
        "tags": [
          "文章",
          "Bug",
          "经验分享",
          "编程"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1652294765397454849",
        "title": "极简 Nginx 学习 + 使用，点到为止",
        "description": "学习前端人必须会的 nginx ~ ，填补「知识坑」",
        "content": "## 极简Nginx学习 + 使用\n\n​\t最近工作中，遇到了需要使用 nginx 的场景，但是我又从来没有学习使用过，于是打算系统的学习使用一下，填补一下自己的「 **知识坑** 」\n\n**下面所有操作都是在 windows 上，如果 mac 可能会不一致**\n\n​\t对于这种必备的技术栈，可以去 Github 上面搜索一下相关教程，Nginx 在 Github 上有一个3.5k star 的文字教程，于是，我就打算使用这个教程 + chatGPT 学习一下这个新的知识，\n\n​\t参考资料：\n\n1. Nginx 极简教程 ：https://github.com/dunwu/nginx-tutorial\n\n​\t我的学习目标\n\n1. 知道什么是 Nginx？它的作用？\n2. 知道如何使用 Nginx？Nginx 有哪些使用场景？\n3. 体验 Nginx ，写 demo\n\n### 什么是 Nginx ？\n\n**Nginx (engine x)** 是一款轻量级的 Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。分析一下这句话：\n\n- 是一个 WEB 服务器，\n- 特点：很轻量，能够反向代理和电子邮件代理\n\n这里有几个概念需要理解：\n\n#### 服务器和 WEB 服务器的区别\n\n- Web服务器是一种计算机程序，它提供了从网页到客户端的传输协议。它的作用是接收来自客户端的HTTP请求，并向客户端返回HTTP响应，以此来提供Web服务。\n- 服务器是指一种计算机系统，它能够处理来自客户端的请求，并提供相应的服务。服务器可以运行各种不同的软件和应用程序，包括Web服务器、邮件服务器、数据库服务器等等。Web服务器是服务器的一种，它特别针对Web应用程序而设计，提供HTTP协议的支持。\n\n因此，Web服务器是服务器（的子集）的一种特定类型，它专门用于提供Web服务。\n\n#### 什么是反向代理\n\n我自己理解的一句话：正向代理，代理的是客户端，例如：VPN，反向代理代理的是服务端：例如：Web 服务器负载均衡，安全访问内部应用（使用 Nginx 作为反向代理服务器，让用户通过外部 URL 访问企业内部的应用程序，例如 GitLab 或者 Jenkins 等。）\n\n反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n![image-20230429175745516](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230429175745516.png)\n\n分析一下上面这张图，可以看到 nginx 可以帮助我们链接客户端和服务端，它提供了很多的能力，帮我们封装了很多客户和服务端通信的能力\n\n### Nginx 实战\n\n#### （1）nginx 初体验\n\n1> 下载： https://github.com/dunwu/nginx-tutorial/blob/master/docs/nginx-ops.md\n\n2> 运行：进入下载的 nginx 目录 输入 nginx ，或者运行目录下的 nginx.exe\n\n> 运行成功后，可看到\n\n![image-20230429182714665](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230429182714665.png)\n\n3> 停止运行：可以使用`nginx -s stop`，这里需要注意，一台电脑可以同时启动多少 nginx 服务，可以使用`tasklist /fi \"imagename eq nginx.exe\"`关闭所有的 nginx ，还有，重启计算机不会直接关闭正在运行的 Nginx 进程。当您重启计算机时，操作系统将会先关闭所有进程，包括 Nginx 进程。但是，在关闭 Nginx 进程之前，操作系统会先向 Nginx 进程发送一个关闭信号，等待 Nginx 进程结束，确保所有数据都已经保存。当您重新启动计算机后，如果您已经正确地配置了 Nginx 的自动启动，那么它将在计算机启动后自动运行。\n\n**nginx**常用命令：\n\n```bash\nnginx -s stop       快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。\nnginx -s quit       平稳关闭Nginx，保存相关信息，有安排的结束web服务。\nnginx -s reload     因改变了Nginx相关配置，需要重新加载配置而重载。\nnginx -s reopen     重新打开日志文件。\nnginx -c filename   为 Nginx 指定一个配置文件，来代替缺省的。\nnginx -t            不运行，仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。\nnginx -v            显示 nginx 的版本。\nnginx -V            显示 nginx 的版本，编译器版本和配置参数。\n```\n\n如果不想每次都敲命令，可以在 nginx 安装目录下新添一个启动批处理文件**startup.bat**，双击即可运行。内容如下：\n\n```bash\n@echo off\nrem 如果启动前已经启动nginx并记录下pid文件，会kill指定进程\nnginx.exe -s stop\n\nrem 测试配置文件语法正确性\nnginx.exe -t -c conf/nginx.conf\n\nrem 显示版本信息\nnginx.exe -v\n\nrem 按照指定配置去启动nginx\nnginx.exe -c conf/nginx.conf\n```\n\n#### （2）我们最熟悉的文件：nginx.conf\n\n在开发、测试环境下，我们都得自己去配置Nginx，就是去配置nginx.conf。nginx.conf是典型的分段配置文件，下面我们来分析下面的 nginx 配置（宝塔面板的）\n\n```yaml\nserver\n{\n    listen 80;\n    server_name pt.xdr630.top;\n    index index.php index.html index.htm default.php default.htm default.html;\n    root /www/wwwroot/pt.xdr630.top;\n    \n    #SSL-START SSL相关配置，请勿删除或修改下一行带注释的404规则\n    #error_page 404/404.html;\n    #SSL-END\n    \n    #ERROR-PAGE-START  错误页配置，可以注释、删除或修改\n    error_page 404 /404.html;\n    error_page 502 /502.html;\n    #ERROR-PAGE-END\n    \n    #PHP-INFO-START  PHP引用配置，可以注释或修改\n    include enable-php-72.conf;\n    #PHP-INFO-END\n    \n    #REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效\n    include /www/server/panel/vhost/rewrite/pt.yunxdr.top.conf;\n    #REWRITE-END\n    \n    #禁止访问的文件或目录\n    location ~ ^/(\\.user.ini|\\.htaccess|\\.git|\\.svn|\\.project|LICENSE|README.md)\n    {\n        return 404;\n    }\n    \n    #一键申请SSL证书验证目录相关设置\n    location ~ \\.well-known{\n        allow all;\n    }\n    \n    location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$\n    {\n        expires      30d;\n        error_log off;\n        access_log /dev/null;\n    }\n    \n    location ~ .*\\.(js|css)?$\n    {\n        expires      12h;\n        error_log off;\n        access_log /dev/null; \n    }\n    access_log  /www/wwwlogs/pt.yunxdr.top.log;\n    error_log  /www/wwwlogs/pt.yunxdr.top.error.log;\n}\n```\n\n1. **listen 80;** 指令表示监听 80 端口，当有请求发送到该端口时，Nginx 将根据配置块中的 server_name 进行请求路由。\n2. **server_name pt.xdr630.top;** 指令表示虚拟主机的域名为 pt.xdr630.top，当有请求发送到该域名时，Nginx 将会处理该请求。\n3. **index index.php index.html index.htm default.php default.htm default.html** 指令表示默认文档列表。当客户端请求的 URL 中未指定文件名时，Nginx 将按照这个顺序寻找默认文档，直到找到为止。\n4. **root /www/wwwroot/pt.xdr630.top** 指令表示该虚拟主机的网站根目录为 /www/wwwroot/pt.xdr630.top。\n5. **location ~ ^/(\\.user.ini|\\.htaccess|\\.git|\\.svn|\\.project|LICENSE|README.md)** 指令表示禁止访问这些文件或目录，当客户端请求这些文件或目录时，Nginx 将返回 404 错误。\n6. **location ~ \\.well-known{ allow all; }** 指令表示允许所有的客户端访问以 .well-known 开头的路径，例如 /well-known/acme-challenge。\n7. **location ^~ /** 表示所有请求都将匹配到该 location 块中。^~ 表示开头匹配，不会被正则表达式覆盖。/ 表示匹配所有请求。\n8. **location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$** 指令表示对于以 gif、jpg、jpeg、png、bmp 和 swf 结尾的请求，Nginx 将启用浏览器缓存，并禁用 error_log，并将访问日志写入 /dev/null。\n9. **location ~ .*\\.(js|css)?$** 指令表示对于以 js 和 css 结尾的请求，Nginx 将启用 12 小时的浏览器缓存，并禁用 error_log，并将访问日志写入 /dev/null。\n10. **access_log** 和 **error_log** 指令用于配置访问日志和错误日志的存储位置。在这个例子中，访问日志存储在 /www/wwwlogs/pt.yunxdr.top.log，错误日志存储在 /www/wwwlogs/pt.yunxdr.top.error.log。\n\n2. **proxy_pass** 指令设置了反向代理的目标地址，即 http://passport.csdn.net。在这个例子中，Nginx 会将所有匹配到该 location 块的请求转发到 http://passport.csdn.net。\n3. **proxy_set_header** 指令用于设置请求头。其中，Host 设置代理目标的 Host 头，X-Real-IP 设置客户端的真实 IP 地址，X-Forwarded-For 设置客户端的 IP 地址，REMOTE-HOST 设置客户端的 IP 地址。这些头信息可以让代理目标服务器了解客户端的真实情况。\n4. **add_header X-Cache $upstream_cache_status** 指令用于在响应头中添加一个名为 X-Cache 的头信息。$upstream_cache_status 表示代理缓存的状态。\n5. **if ( $uri ~* \"\\.(gif|png|jpg|css|js|woff|woff2)$\" ) { }** 表示对于某些特定的静态资源，不使用代理缓存。这些资源的文件扩展名包括 gif、png、jpg、css、js、woff 和 woff2。\n6. **proxy_ignore_headers Set-Cookie Cache-Control expires** 指令用于忽略来自代理目标服务器的某些响应头信息。在这个例子中，被忽略的头信息包括 Set-Cookie、Cache-Control 和 expires。\n7. **proxy_cache** 指令用于启用 Nginx 缓存。这个例子中使用的是名为 cache_one 的缓存区。\n8. **proxy_cache_key $host$uri$is_args$args** 指令用于设置缓存键值。缓存键值的组成包括 $host、$uri、$is_args 和 $args 四个变量。其中，$host 表示主机名，$uri 表示请求的 URI，$is_args 表示是否带参数，$args 表示请求参数。\n9. **proxy_cache_valid 200 304 301 302 1m** 指令用于设置缓存的有效期。在这个例子中，200、304、301 和 302 表示缓存的状态码，1m 表示缓存时间为 1 分钟。\n\n该配置文件片段使用了 Nginx 的多个模块和指令，包括\n\n- 监听端口、\n- 虚拟主机、\n- 默认文档列表、\n- 访问控制、\n- 浏览器缓存、\n- 访问日志和错误日志，\n- 反向代理和缓存功能，可以提高 Web 服务器的性能和可用性，并提供更好的用户体验。\n\nNginx 还有很多知识需要去学习，但是我现在应该用不到，如果学习不使用很快就会忘记，所有等我使用的时候再看文档：https://docs.nginx.com/\n\n\n\n其实我们部署静态网页只需要配置下面几个参数即可：\n\n```yaml\nserver\n{\n    listen 80;\n    server_name pt.xdr630.top;\n    index index.php index.html index.htm default.php default.htm default.html;\n    root /www/wwwroot/pt.xdr630.top;\n }\n```\n\n\n\n### Nginx的一些问题？\n\n1. Nginx如何做到热部署？\n\n> 所谓热部署，就是配置文件nginx.conf修改后，不需要stop Nginx，不需要中断请求，就能让配置文件生效！（nginx -s reload 重新加载 /nginx -t检查配置 /nginx -s stop 快速关闭 nginx ）\n\n答：修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的worker进程，至于老的worker进程，等把那些以前的请求处理完毕后，kill掉即可。\n\n2. 为什么要用Nginx？\n3. 为什么Nginx性能这么高？\n4. Nginx是如何实现高并发的？\n5. Nginx是如何处理一个请求的呢？\n\n以上请看：https://cloud.tencent.com/developer/article/1499521\n\n6. Nginx如何做到高并发下的高效处理？\n7. Nginx挂了怎么办？\n8. Nginx如何做到高并发下的高效处理？\n\n以上请看：https://www.zhihu.com/search?type=content&q=nginx%20\n\n### 参考\n\n1. 前端必备知识之 Nginx ：https://juejin.cn/post/7108394145068089374\n2. 前端 nginx 之路：https://zhuanlan.zhihu.com/p/458905411\n3. nginx 下载安装，启动，关闭：https://juejin.cn/post/7000907531191058468\n4. 8分钟学习 nginx ：https://www.zhihu.com/search?type=content&q=nginx%20\n\n通过学习，我基本知道了 nginx 的作用，nginx.conf 的一些常用参数的含义，如何配置该文件， ",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/pKdWZ3b3-NGINX-Docs-horiz-white-type.svg",
        "language": null,
        "viewNum": 84,
        "thumbNum": 3,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-04-29T12:52:24.000+00:00",
        "updateTime": "2023-05-06T00:55:31.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 5,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-06T23:06:53.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-04-29T12:23:26.000+00:00"
        },
        "tags": [
          "文章",
          "前端",
          "笔记"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1651418389941366785",
        "title": "刚进公司就负责项目，把老弟整蒙了！",
        "description": null,
        "content": "大家好，我是鱼皮，先把封面图送给大家：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/005J4OU5ly1h6izwbgiuqj30zk0zkajf.jpeg)\n\n又快到周末了，今天分享一些轻松的编程经验~\n\n还记得我学编程的老弟小阿巴么？他目前大二，听说最近刚刚找到了一家创业公司的暑期实习。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230331132549713.png)\n\n前两天小阿巴又跑来向我诉苦了：鱼皮 gie gie，我不是找了份暑期实习嘛，结果还没到暑假呢，公司的老大就联系我了，说公司最近有很多新项目要启动，等我暑假再来准备估计来不及了，让我提前先调研一下新项目的技术选型。\n\n鱼皮：这不是挺好的么？还没进公司，就已经成为项目负责人了哈哈。\n\n小阿巴：好个毛 🥚 啊，以前我自己都是跟着网上的教程学做项目，把老师的代码拉下来改几下，这让我负责一个项目，我一点底气和思路都没有。还有他说的什么 “技术选型”，我都没听说过！彻底蒙圈了。。。\n\n鱼皮：嗯，这确实是个问题，看来得跟你科普一下 “技术选型” 了。先考你一下，你知道什么是技术选型么？\n\n小阿巴：emm，我猜就是用什么技术来开发这个项目？比如开发前端用 Vue、开发后端用 Spring Boot？\n\n鱼皮：不错，如果把做项目比喻成打仗，那么技术选型就相当于打仗之前选择武器。你要选择合适的武器才能打胜仗，选择合适的技术才能更好地完成项目。\n\n小阿巴：但有个问题，现在主流的开发技术不就那么几种么，像我上面说的 Vue、Spring Boot？有啥好选的？\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230331133744918.png)\n\n鱼皮：你说的其实只是技术选型的其中一点，也是最浅的一层。技术选型不止有 “选择开发框架”，还包括很多不同的方面和细节。\n\n由浅入深来看，技术选型包括：\n\n1）用哪类技术？比如编程语言、开发框架、数据存储、缓存\n\n2）具体用什么技术？比如编程语言用 Java 还是 Go？开发框架用 Spring 还是 Netty？缓存用 Redis 还是 Memcached？\n\n3）技术用哪个版本？比如用 Java 8 还是 11？Vue 2 还是 Vue 3？Redis 5 还是 6？\n\n4）具体用到哪些技术特性？比如 Spring 的 AOP、Redis 的 GEO 高级数据结构等。\n\n\n\n小阿巴：我滴妈呀！这么复杂嘛，我之前根本没想过这些，好像也想不到。。。\n\n鱼皮：这是很正常的，因为之前你都是自己跟着教程做项目，用什么技术、用哪个版本都是老师给你提前规划好的。\n\n小阿巴：确实唉，我觉得有点太麻烦了。。。能不能不做技术选型呀！老夫直接用 Spring Boot + Vue 一把梭。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230331134500590.png)\n\n鱼皮：哈哈，技术选型当然不是绝对的呀，比如你在学校自己做项目，那你就用熟悉的技术或者想学的技术即可。但是等当你进入企业、尤其是负责项目时，就必须要跟团队同学一起确认技术选型。而且对于规模越大、越复杂的项目，你要考虑的技术选型的角度和深度要求就越高！不能再像自己做项目一样随便了。\n\n小阿巴：我就随便，又怎样？\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230331134623409.png)\n\n鱼皮：可以的，我看你是不到黄河心不死不见棺材不落泪欲穷千里目更上一层楼啊！给你讲讲我在学校的时候有次带团队做项目时，不做技术选型的翻车经历吧。\n\n很多年前了，当时我们在做一个校园贴吧网站，记得我是用 React  来开发前端页面的。刚开始很顺利，但直到有一天需要开发帖子页面信息状态保存功能的时候，才发现 React 不像 Vue Router 一样有现成的 keep-alive，后来又花了好久才找到一个类似的组件，结果还一堆 Bug。。。\n\n唉，当时确实是经验不足呀。如果最开始就考虑到这点，选择 Vue 系列技术栈，那么就能节省很多时间了。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230331141407156.png)\n\n小阿巴：我悟了！就是说在开发一个完整项目前，我们要先整体思考一下实现项目功能可能会用到的一些技术，这样不至于到后面才发现难以实现？\n\n鱼皮：good，是这样。越是对项目侵入性强的技术，后期的改动成本就越大。比如我刚刚举的例子，等你页面都写了几十个了，再去切换开发框架，就会很麻烦；而且有的时候，你给项目引入新的组件或类库，可能会和现有的库版本冲突，导致后面项目跑不起来。这些其实都是技术选型不当带来的问题，也是我们做技术选型的必要性。\n\n小阿巴：原来如此，那做技术选型有没有什么好的经验呢？\n\n鱼皮：一句话，我们做技术选型的目标是 **在有限的条件下、选取特定场景下的技术最优解。**\n\n有限条件包括我们团队同学会的技术、我们的时间和金钱成本。比如大家都只会 Java、项目又急着上线，那肯定优先选择 Java 相关技术栈，不要因为什么 Go 语言的性能高就让大家加班去学 Go。再比如公司很有钱，但是缺人手，那么很多服务（比如数据库）就不用自己搭建了，直接买大厂云服务即可。\n\n特定场景是指我们的技术选型一定要围绕着业务和需求来做，可以思考以下几点：\n\n1. 你的业务量级有多大：如果用户数巨多，要不要用 Nginx 或者 LVS 来做个负载均衡？如果存储量巨大，要不要使用分布式数据库、要不要搞分库分表？\n2. 系统的核心业务流程和关键数据结构是什么？比如要做一个管理系统，那么数据库选择主流的关系型数据库 MySQL 就好。而如果要做数据分析系统，那么应该选择 OLAP 利好的数据库，比如 Postgre SQL、ClickHouse 等。\n3. 系统更注重哪些性能？比如日志收集的场景更注重高性能和吞吐量，那么可以选择 Kafka 消息队列来采集；比如注重低延迟以及消息的准确性，那么可以选择 RabbitMQ 等。很多时候，我们做技术选型和设计算法一样，没有绝对的最优解，而是对时间、空间、稳定性、可用性等等的综合权衡。\n\n小阿巴：大哥，我悟了，您别念了！\n\n鱼皮：哈哈，另外还有两个建议\n\n1. 做技术选型时，可以通过编写最简单的 Demo 来快速验证下技术是否可用，不要直接拍板！\n2. 原则上优先选择知名度高的、开源的、用户多生态好的技术，没几个人用的技术，估计你用的话就是踩雷去了。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230331140943700.png)\n\n小阿巴：我明白了，那我就先问清楚我们这个项目大概要做哪些功能、预计有多少用户和存储需求，再根据这些到网上搜技术选型！\n\n鱼皮：糊涂啊！都 2023 年了，直接问 ChatGPT！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230331141255552.png)\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/2ncX16CZ-v2-c49bc2a3b292b43643c5dab7d441e778_1440w.jpg",
        "language": null,
        "viewNum": 246,
        "thumbNum": 12,
        "favourNum": 3,
        "commentNum": 0,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-04-27T02:50:00.000+00:00",
        "updateTime": "2023-05-06T00:17:10.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 1310,
          "coin": 170,
          "followeeNum": 599,
          "followNum": 5,
          "followStatus": null,
          "vipExpireTime": "2025-12-17T05:00:02.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-05-05T14:37:02.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "92",
    "size": "10",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "10"
  },
  "message": "ok"
}